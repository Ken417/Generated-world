#pragma kernel TEST1
#pragma kernel TEST2

const float PI = 3.141592653589793238462;

RWTexture2D< float4 > resultTex;

float width, height;

float f1, f2, f3;
int i1, i2, i3;



[numthreads(1, 1, 1)]
void TEST1(uint2 id : SV_DispatchThreadID)
{
	resultTex.GetDimensions(width, height);

	float2 st = float2(id.x / width, id.y / height);

	float3 color = float3(0,0,0);

	st *= f1; //f1 = scale
	st = frac(st); // Wrap arround 1.0

	// Now we have 3 spaces that goes from 0-1

	color = float3(st, 0.0);
	//color = vec3(circle(st,0.5));

	resultTex[id] = float4(color, 1.0);
}

float2 rotate2D(float2 _st, float _angle) {
	_st -= float2(0.5f, 0.5f);
	//_st = mul(float2x2(cos(_angle), -sin(_angle), sin(_angle),cos(_angle)),_st);
	float2 st2;
	st2.x = _st.x * cos(_angle) - _st.y * sin(_angle);
	st2.y = _st.x * sin(_angle) + _st.y * cos(_angle);
	st2 += float2(0.5f, 0.5f);
	return st2;
}

float2 tile(float2 _st, float _zoom) {
	_st *= _zoom;
	return frac(_st);
}

float box(float2 _st, float2 _size, float _smoothEdges)
{
	_size = float2(0.5f, 0.5f) - _size * 0.5f;
	float2 aa = float2(_smoothEdges * 0.5, _smoothEdges * 0.5);
	float2 uv = smoothstep(_size, _size + aa, _st);
	uv *= smoothstep(_size, _size + aa, float2(1.0, 1.0) - _st);
	return uv.x * uv.y;
}

[numthreads(1, 1, 1)]
void TEST2(uint2 id : SV_DispatchThreadID)
{
	resultTex.GetDimensions(width, height);

	float2 st = float2(id.x / width, id.y / height);

	float3 color = float3(0,0,0);

	// Divide the space in 4
	st = tile(st, i1);

	// Use a matrix to rotate the space 45 degrees
	st = rotate2D(st, PI * f1);

	// Draw a square
	float c = box(st, float2(f2, f2), f3);
	color = float3(c,c,c);
	// color = float3(st,0.0);

	resultTex[id] = float4(color, 1.0);
}

//float rand(float2 c)
//{
//	return frac(sin(dot(c.xy, float2(12.9898, 78.233))) * 43758.5453);
//}

